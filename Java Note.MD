接口和抽象类的区别：

最大的区别是：

1：抽象类能提供方法的实现，而接口不行，接口只能定义方法，不能有实现方法的代码。

2：抽象类的数据成员可以使任何类型，而接口只能是final static。

3：抽象类可以有静态方法可静态代码段，而接口没有。

4：接口是实现多个，而java只能是单继承。

从设计层面上来说，抽象类是模板式设计，如果在抽象类中添加新的方法，所有子类都能拥有该方法；而接口是行为规范，是辐射式设计，在接口中
添加新的方法，所以实现类都不能编译通过，这是接口的缺点。

结合各自的优势，经典的设计模式就是接口在最上层，抽象类实现这个接口，其他的具体类可以自由的选择是实现接口还是继承抽象类。


Java多线程：

描述任务的方式，实现Runnable接口，编写run方法，将Runnable对象提交给Thread构造器，Thread调用start方法执行初始化操作，之后自动调用run
方法，注意，start方法只能调用一次，调用多次会报错。

Executor执行器可以来管理Thread对象，避免显示的创建对象，实际上，new显式的创建对象比较耗时，只用这种方式把线程一次性创建好并放入池中
，需要的时候再拿出来，更高效。主要的有FixThreadPool, CachedThreadPool, SingleThreadPool. 

从任务中产生返回值的接口Callable， Runable执行独立的任务，但是它不返回任何值。Callable是一种具有类型参数的泛型，实现call方法
返回一个值。通过ExecutorService.submit()调用，并且能够返回一个Future对象。

下面说一下Runable和Callable的区别：

1.Callable可以返回一个类型V，而Runnable不可以

2.Callable能够抛出checked exception,而Runnable不可以。

3.Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的

4.Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.

上面只是简单的不同，其实这两个接口在用起来差别还是很大的。Callable与executors联合在一起，在任务完成时可立刻获得一个更新了的
Future。而Runable却要自己处理
 
Future接口，一般都是取回Callable执行的状态用的。其中的主要方法：

cancel，取消Callable的执行，当Callable还没有完成时

get，获得Callable的返回值

isCanceled，判断是否取消了

isDone，判断是否完成

休眠：

sleep(), 不释放锁

优先级： setPriority(),

后台线程：setDaemon()；派生出来的子类也是后台

加入一个线程：t.join(); 词线程将会被挂起，直到目标线程t结束才恢复。

一个Condition和一个Lock关联在一起，就想一个条件队列和一个内置锁相关联一样。要创建一个Condition，可以在相关联的Lock上调用Lock.newCondition方法。正如Lock比内置加锁提供了更为丰富的功能，Condition同样比内置条件队列提供了更丰富的功能：在每个锁上可存在多个等待、条件等待可以是可中断的或者不可中断的、基于时限的等待，以及公平的或非公平的队列操作。

与内置条件队列不同的是，对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会依照FIFO顺序从Condition.await中释放。

虚拟机类加载机制：

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可被虚拟机直接使用的java类型。

类型的加载和初始化过程都是在程序的运行期间完成的， 运行时类加载特性。

7个阶段：

加载，（验证，准备，解析）--> 统称连接， 初始化，使用，卸载， 按照顺序来，但是解析不一定，某些情况可以再初始化之后再开始，以
支持动态绑定，多态。

5种情况必须进行初始化：

1） new、getstatic、putstatic等关键字

2）使用java.lang.reflect对类进行反射调用

3）父类没有被初始化，先初始化父类

4）执行main函数时，先初始化包含main方法的那个类，包括调用构造函数和执行静态代码块等

5）不太懂。。。。

类加载的过程！！1

加载：完成3件事

1）通过类的权限名来获取定义此类的二进制字节流。

2）将这个字节流所代表的静态存储区转化为方法区的运行时数据结构。

3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口。程序可通过这个类访问方法区中这些类型
数据

验证：确保class文件的字节流包含的信息符合当前虚拟机的要求。

文件格式验证：是否以魔数开头，主次版本号，常量池中常量类型。。。

元数据验证：是否有父类，是否继承了不允许继承的类，如果类不是抽象类，是否实现了父类或接口要求的方法。。。

字节码验证：保证被校验的类在运行时不会做出危害虚拟机的事件。

符号引用验证：校验虚拟机将符号引用转化为直接引用，如通过字符串描述的全限定名能否找到对应的类

验证非常重要，但不是必须的，如果第三方包已被方法验证，可以使用-Xverity:none参数来关闭类验证，缩短时间。

准备：正式为类变量分配内存并设置初始值，都在方法区中发生。仅包含类变量，被static修饰的。

    public static int value = 123;
    
在准备阶段后方法区中有value这个变量，但是值为0.在初始化阶段才会执行赋值操作。

    public static final value = 123;
    
字段属性有ConstantValue属性，在准备阶段直接赋值。

解析：将常量池内的符号引用替换为直接引用的过程。

1）类或接口的解析：

2）字段解析：

3）类方法解析：

4）接口方法解析：

初始化：类加载的最后一步，真正执行java代码段，前面的都是由虚拟机完成控制的。变量的直接赋值，执行静态代码块，按出现的顺序。
父类的操作会在子类的操作之前，因此最先执行的是Object的东西，静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的，只能赋值，不能访问，如：

    public calss Test{
        static {
            i = 0;
            System.out.print(i); //报错
        }
        static int i = 1;
    }
    
接口不能使用静态语句块，整个初始化的在多线程环境中会被正确的加锁，同步。

类加载器：类的唯一性由加载它的类加载器和这个类本身一同确定，每个类加载器，都有一个独立的类名称空间。

双亲委派模型：

从虚拟机的角度，两种不同的加载器：启动类加载器，由C++实现，虚拟机的自身部分；所有其它类加载器，由Java实现，独立于虚拟机外部，更细致的划分：

启动类加载器，负责加载<JAVA_HOME>\lib目录中，或者被-Xbootclasspath参数所指定的路径中，它无法被Java程序直接引用。

扩展类加载器：负责加载<JAVA_HOME>\lib\ext目录中或被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用。

应用程序加载器：它是getSystemClassLoader()方法的返回值，也称做系统类加载器，负责加载用户类路径ClassPath上指定的类库，开发者直接使用，默认类加载器。

双亲不是强制性的约束条件，而是推荐的实现方式。

启动类加载器 <--- 扩展类加载器 <--- 应用类加载器 <--- 自定义类加载器

父子关系不是继承，而是组合

Java内存模型与线程

主内存和工作内存：，所有变量都存在主内存中，每条线程还有自己的工作内存，线程的工作内存保存了被线程使用到变量的主内存的副本拷贝，线程对变量的操作必须在工作内存中，不能直接读写主内存

volatile是Java虚拟机提供的最轻量级的同步机制，它具有特殊的访问规则，保证变量对所有的线程的可见性，每次操作工作内存的数据，都会刷新一次

线程安全：

同步和互斥：同步是多个线程并发访问共享数据时，保证贡献数据在同一时刻只被一个或者一些线程使用，互斥是只能有一个线程使用，临界区，互斥量，信号量。

synchronized关键字是基本的互斥方法，会在同步快前后分别生成monitorenter和monitorexit字节码指令，且都需要一个reference类型的参数，首先要获取对象锁，获取失败会阻塞。

用java.util.concurrent包实现同步，重入锁(ReentrantLock)实现同步，高级功能，等待可中断，可实现公平锁，锁绑定多个条件。

等待可中断：当持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待。

公平锁：多个线程等待同一锁时，必须按照申请锁的时间顺序来获取锁，synchronized和ReentrantLock默认都是非公平的，都后者可以通过带布尔值的构造函数要求使用公平锁。

锁可绑定多个Condition对象

互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，称为阻塞同步。还有一种基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用数据，成功，如果有争用，冲突在补偿，需要硬件指令支持。

锁的优化：

自旋锁和自适应自旋：让线程忙等待，不断尝试获取锁，自适应就是自旋时间不再固定

锁消除：
在虚拟机即时编译运行时，对一些同步代码块，被检测到不可能存在共享数据的竞争，把锁消除。判断依据是逃逸分析，堆的数据不会逃逸出去被其他线程访问到，就可以把他们当做栈数据操作。

锁粗化：
频繁加锁和释放锁不好，检测到这样的操作会把加锁操作扩展到整个操作外面，例如典型的for (StringBuffer.append("ff"))

类加载器收到类加载的请求，不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，一直传到最顶层，只有当父类加载器反馈无法完成加载请求，子类加载器才会尝试


