接口和抽象类的区别：

最大的区别是：

1：抽象类能提供方法的实现，而接口不行，接口只能定义方法，不能有实现方法的代码。

2：抽象类的数据成员可以使任何类型，而接口只能是final static。

3：抽象类可以有静态方法可静态代码段，而接口没有。

4：接口是实现多个，而java只能是单继承。

从设计层面上来说，抽象类是模板式设计，如果在抽象类中添加新的方法，所有子类都能拥有该方法；而接口是行为规范，是辐射式设计，在接口中
添加新的方法，所以实现类都不能编译通过，这是接口的缺点。

结合各自的优势，经典的设计模式就是接口在最上层，抽象类实现这个接口，其他的具体类可以自由的选择是实现接口还是继承抽象类。


Java多线程：

描述任务的方式，实现Runnable接口，编写run方法，将Runnable对象提交给Thread构造器，Thread调用start方法执行初始化操作，之后自动调用run
方法，注意，start方法只能调用一次，调用多次会报错。

Executor执行器可以来管理Thread对象，避免显示的创建对象，实际上，new显式的创建对象比较耗时，只用这种方式把线程一次性创建好并放入池中
，需要的时候再拿出来，更高效。主要的有FixThreadPool, CachedThreadPool, SingleThreadPool. 

从任务中产生返回值的接口Callable， Runable执行独立的任务，但是它不返回任何值。Callable是一种具有类型参数的泛型，实现call方法
返回一个值。通过ExecutorService.submit()调用，并且能够返回一个Future对象。

下面说一下Runable和Callable的区别：

1.Callable可以返回一个类型V，而Runnable不可以

2.Callable能够抛出checked exception,而Runnable不可以。

3.Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的

4.Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.

上面只是简单的不同，其实这两个接口在用起来差别还是很大的。Callable与executors联合在一起，在任务完成时可立刻获得一个更新了的
Future。而Runable却要自己处理
 
Future接口，一般都是取回Callable执行的状态用的。其中的主要方法：

cancel，取消Callable的执行，当Callable还没有完成时

get，获得Callable的返回值

isCanceled，判断是否取消了

isDone，判断是否完成

多线程未完待续：

虚拟机类加载机制：

虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可被虚拟机直接使用的java类型。

类型的加载和初始化过程都是在程序的运行期间完成的， 运行时类加载特性。

7个阶段：

加载，（验证，准备，解析）--> 统称连接， 初始化，使用，卸载， 按照顺序来，但是解析不一定，某些情况可以再初始化之后再开始，以
支持动态绑定，多态。

5种情况必须进行初始化：

1） new、getstatic、putstatic等关键字

2）使用java.lang.reflect对类进行反射调用

3）父类没有被初始化，先初始化父类

4）执行main函数时，先初始化包含main方法的那个类，包括调用构造函数和执行静态代码块等

5）不太懂。。。。

类加载的过程！！1

加载：完成3件事

1）通过类的权限名来获取定义此类的二进制字节流。

2）将这个字节流所代表的静态存储区转化为方法区的运行时数据结构。

3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口。程序可通过这个类访问方法区中这些类型
数据

验证：确保class文件的字节流包含的信息符合当前虚拟机的要求。

文件格式验证：是否以魔数开头，主次版本号，常量池中常量类型。。。

元数据验证：是否有父类，是否继承了不允许继承的类，如果类不是抽象类，是否实现了父类或接口要求的方法。。。

字节码验证：保证被校验的类在运行时不会做出危害虚拟机的事件。

符号引用验证：校验虚拟机将符号引用转化为直接引用，如通过字符串描述的全限定名能否找到对应的类

验证非常重要，但不是必须的，如果第三方包已被方法验证，可以使用-Xverity:none参数来关闭类验证，缩短时间。

准备：正式为类变量分配内存并设置初始值，都在方法区中发生。仅包含类变量，被static修饰的。

    public static int value = 123;
    
在准备阶段后方法区中有value这个变量，但是值为0.在初始化阶段才会执行赋值操作。

    public static final value = 123;
    
字段属性有ConstantValue属性，在准备阶段直接赋值。

解析：将常量池内的符号引用替换为直接引用的过程。

1）类或接口的解析：

2）字段解析：

3）类方法解析：

4）接口方法解析：

初始化：类加载的最后一步，真正执行java代码段，前面的都是由虚拟机完成控制的。变量的直接赋值，执行静态代码块，按出现的顺序。
父类的操作会在子类的操作之前，因此最先执行的是Object的东西，静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的，只能赋值，不能访问，如：

    public calss Test{
        static {
            i = 0;
            System.out.print(i); //报错
        }
        static int i = 1;
    }
    
接口不能使用静态语句块，整个初始化的在多线程环境中会被正确的加锁，同步。

下一节是类加载器，未完待续。。。

